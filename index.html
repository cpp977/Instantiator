<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Instantiator: Instantiator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/cpp977/Instantiator" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Instantiator
   </div>
   <div id="projectbrief">Generate c++ template instantiations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Instantiator </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doxy_2main"></a>clang based tool to automatically insert all needed explicit instantiations in implementation files for <code>c++</code> projects.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Motivation</h1>
<p>The source code organization for c++ projects consists of header files containing the declarations and source files containing the implementation. For example, a header file for a <code>class Point</code> could look as follows: </p><div class="fragment"><div class="line"><span class="comment">//Point.hpp</span></div>
<div class="line"><span class="preprocessor">#ifndef POINT_HPP_</span></div>
<div class="line"><span class="preprocessor">#define POINT_HPP_</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Point {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Point() {}</div>
<div class="line">    </div>
<div class="line">    Point(<span class="keyword">const</span> <span class="keywordtype">double</span> x_in, <span class="keyword">const</span> <span class="keywordtype">double</span> y_in);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">double</span> norm() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> shift(<span class="keyword">const</span> Point other);</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">double</span> x=0., y=0.;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> The corresponding source file would then be: </p><div class="fragment"><div class="line"><span class="comment">//Point.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;Point.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"> </div>
<div class="line">Point::Point(<span class="keyword">const</span> <span class="keywordtype">double</span> x_in, <span class="keyword">const</span> <span class="keywordtype">double</span> y_in) {</div>
<div class="line">    x=x_in;</div>
<div class="line">    y=y_in;</div>
<div class="line">}</div>
<div class="line">    </div>
<div class="line"><span class="keywordtype">double</span> Point::norm()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> std::sqrt(x*x+y*y);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Point::shift(<span class="keyword">const</span> Point other) {</div>
<div class="line">    x += other.x;</div>
<div class="line">    y += other.y;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This decomposition has several advantages:</p><ul>
<li>The header file defines a clear interface which can be used to see the content of the class. The concrete implementation is hidden.</li>
<li>The source file can be compiled <b>separately</b> into an object file.</li>
<li>The header file needs less <code>include</code> directives.</li>
<li>When the implementation needs to be changed, only the source file needs to recompiled and <b>not</b> other files which uses the class by including the header.</li>
</ul>
<p>However, the <code>Point</code> class above is not generic as it has the fixed type <code>double</code> for the coordinates. This can be changed easily because generic programming is well supported by c++ using <code>templates</code>. The generic <code>Point</code> class header is (without the usage of <code>concepts</code>): </p><div class="fragment"><div class="line"><span class="comment">//Point.hpp</span></div>
<div class="line"><span class="preprocessor">#ifndef POINT_HPP_</span></div>
<div class="line"><span class="preprocessor">#define POINT_HPP_</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt;</div>
<div class="line"><span class="keyword">class </span>Point {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Point() {}</div>
<div class="line">    </div>
<div class="line">    Point(<span class="keyword">const</span> Scalar x_in, <span class="keyword">const</span> Scalar y_in);</div>
<div class="line">    </div>
<div class="line">    Scalar norm() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> shift(<span class="keyword">const</span> Point other);</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Scalar x=0., y=0.;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> And the corresponding source file would be: </p><div class="fragment"><div class="line"><span class="comment">//Point.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;Point.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt;</div>
<div class="line">Point&lt;Scalar&gt;::Point(<span class="keyword">const</span> Scalar x_in, <span class="keyword">const</span> Scalar y_in) {</div>
<div class="line">    x=x_in;</div>
<div class="line">    y=y_in;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt;</div>
<div class="line">Scalar Point&lt;Scalar&gt;::norm()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> std::sqrt(x*x+y*y);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt;</div>
<div class="line"><span class="keywordtype">void</span> Point&lt;Scalar&gt;::shift(<span class="keyword">const</span> Point other) {</div>
<div class="line">    x += other.x;</div>
<div class="line">    y += other.y;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Now, it becomes a problem that the declaration and the definition are separated. When the source file <code>Point.cpp</code> is compiled to an object file, the compiler does not know a type for <code>Scalar</code>. It can not generate any object code. This is written in the c++ standard: </p><blockquote class="doxtable">
<p>&zwj;A class template by itself is not a type, or an object, or any other entity. No code is generated from a source file that contains only template definitions. In order for any code to appear, a template must be instantiated: the template arguments must be provided so that the compiler can generate an actual class (or function, from a function template). </p>
</blockquote>
<p>To resolve this issue, one can put the definition into the header file. This shifts the object/binary code generation to the compilation step where the header is included. Assuming that a concrete type for <code>Scalar</code> is given in this file, all the class methods of <code>Point</code> can be compiled. But with this solution, one loses the advantages from above. Another possibility is to insert one or several explicit instantiations into <code>Point.cpp</code> to give the compiler one or several concrete types for <code>Scalar</code>. Adding for example </p><div class="fragment"><div class="line"><span class="keyword">template</span> <span class="keyword">class </span>Point&lt;double&gt;;</div>
</div><!-- fragment --><p> at the end of <code>Point.cpp</code> would cause object code for all members of <code>Point</code> for the type <code>double</code>. With this solution one can keep separate translation units but it has other drawbacks:</p><ul>
<li>The <code>Point</code> class can not be used with any type but only with those where there is an explicit instantiation.</li>
<li>The explicit class instantiation causes the compilation of <b>all</b> members. However if the class is implicitly instantiated, only code for the <b>used</b> members is generated. Implicit instantiation would occur if you put the definiton into the header and take the concrete types from the usage of the class.</li>
<li>All the explicit instantiations needs to be inserted manually which causes extra maintenance work.</li>
</ul>
<p>Note, that the second point could be circumvented by not using explicit class instantiations but only explicitly instantiate certain members. For example </p><div class="fragment"><div class="line"><span class="keyword">template</span> <span class="keywordtype">void</span> Point&lt;double&gt;::shift(<span class="keyword">const</span> Point&lt;double&gt; other);</div>
</div><!-- fragment --><p> Buth this approach is not maintainable for large class templates.</p>
<p>This tool aims to provide a third solution, namely to inject the explicit member instantiations (or free function instantiations) automatically by using the information from a final main file. This means that the <code>Point</code> class is separated in header and source file but the source file is <b>not</b> compiled to a library. A user of the <code>Point</code> class will include a cmake target to build the library for <code>Point</code> with the dependency <code>Point.cpp</code>. Then the main target can become the <code>Point</code> library as a dependency. With this setup, the tool can insert all needed explicit instantiations into <code>Point.cpp</code> by using the information from the main target. This is achieved by using the powerful <code>clang</code> library <em>libtooling</em> for analyzing clangs abstract syntax tree (AST).</p>
<h1><a class="anchor" id="autotoc_md2"></a>
The clang AST</h1>
<p>To get familiar with the clang AST, see the <a href="https://clang.llvm.org/docs/IntroductionToTheClangAST.html">clang AST introduction</a>. The AST is a structured version of a c++ program. It contains nodes for the different statements and declarations in the code. Clang has two different base classes <code>Stmt</code> and <code>Decl</code> which do not have a common base. For the purpose of this tool, the <code>FunctionDecl</code> and <code>CXXMethodDecl</code> classes are most important which both derive from <code>Decl</code>. To filter specific nodes from the AST, clang provides <a href="https://clang.llvm.org/docs/LibASTMatchersReference.html">AST matchers</a>.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
General procedure</h1>
<p>In order to inject the needed instantiations, the tool is iterating an inner two step procedure. The iteration is necessary because an explcit instantiation in a source file can lead to new instantiations in other source files. This is because if an explicit instantiation is inserted, new code become visible, namely the code of the definiton of the function which was instantiated. The tool starts with the <em>main</em> translation unit, i.e. the source file in which the <code><a class="el" href="Instantiator_8cpp.html#a217dbf8b442f20279ea00b898af96f52">main()</a></code> function is present. This source file is added to the <code>workList</code>. Then the tool is processing the working list and does for each file in the working list an inner two step procedure. The first step is the <em>lookup</em> step in which the AST of a translation unit is scanned for template instantiations for which <b>no</b> definition is present. The result of the <em>lookup</em> step is stored as a <code>toDoList</code>. In the second step, the <em>insertion</em> step, all other translation units are scanned if they do provide the missing definiton of an item in the <code>toDoList</code>. If so, the corresponding explicit instantiation is inserted in the source file of this translation unit and the item is removed from the <code>toDoList</code>. Each time, an explicit instantiation is inserted, the corresponding source file is added to the <code>workList</code>. The tool stops if the <code>workList</code> is empty. Remaining elements in the <code>toDoList</code> might cause linking errors unless the object code for these functions is added by linking an already compiled library with the respective definiton.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Lookup step &ndash; find template instantiations with missing definiton</h2>
<p>The <em>lookup</em> step is performed for a given source file (.cpp file). During this step, the AST of the corresponding source file is processed. When the definiton of function templates or class template member functions is separated into a different translation unit, the AST may contain nodes <code>FunctionDecl</code> or <code>CXXMethodDecl</code> which are template instantiations but which have <b>no</b> definition within this AST. The AST matcher which matches these nodes is <a class="el" href="Matcher_8hpp.html#aa490284074dd793c672884a4cdce42a0">TemplInstWithoutDef()</a>: </p><div class="fragment"></div><!-- fragment --><p> This matcher also excludes a list of custom namespaces <code>excluded_names</code> from the search which can be passed to the tool via the commandline. For each match, all relevant data is loaded into an <code><a class="el" href="structInjection.html" title="Struct for the collection of all relevant data for a template instantiation which needs to be inserte...">Injection</a></code> by using the factory functions <code><a class="el" href="structInjection.html#a26e85cb6e2fadf5441c7f03f6bb48245">Injection::createFromFS()</a></code> and <code><a class="el" href="structInjection.html#a5ba36f8d1f3d7524de69c736d2c82f3f">Injection::createFromMFS()</a></code>. </p>
<h2><a class="anchor" id="autotoc_md5"></a>
Insertion step &ndash; inject the instantations where the definitons are present</h2>
<p>The <em>insertion</em> step is performed for all other source files of the build except the source file which was scanned in the <em>lookup</em> step. Therefore, this step involves an outerloop over the source files. For each source file, the corresponding AST is analysed with the AST matcher <a class="el" href="Matcher_8hpp.html#ac8e305e4e823da5613163fcb2ec96a73">FuncWithDef()</a>: </p><div class="fragment"></div><!-- fragment --><p> This matcher takes again a list of custom namespaces <code>excluded_names</code> which will be ignored from the search. This matcher returns any <code>FunctionDecl</code> or <code>CXXMethodDecl</code> that contains a definiton. For each match, the tool checks whether the present function is a template and does match any of the functions from the <code>toDoList</code>. Remember, that the <code>toDoList</code> has functions for which a definiton was <em>missing</em>, so the tool basically search if the definition is present in any other source file. If an item of the <code>toDoList</code> does match, the tool inserts the corresponding explicit instantiation. If on the other hand, the present function is a template specialization and matches an item of the <code>toDoList</code>, this item will be directly deleted, since the necessary instantiation is already present. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Feb 24 2024 11:26:59 for Instantiator by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
<script type="text/javascript">
  // script for doxygen 1.9.2
  $(function() {
      toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
      toggleButton.title = "Toggle Light/Dark Mode"
      $(document).ready(function(){
          document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
      })
      $(window).resize(function(){
          document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
      })
  })
</script>
</body>
</html>
